# AUTOGENERATED! DO NOT EDIT! File to edit: pointsource.ipynb (unless otherwise specified).

__all__ = ['PointSourceGaussian']

# Cell
import torch
from .transforms import *

# Cell
class PointSourceGaussian(TransfromBase):
    """
    Sample Point Source from Gaussina and Binomial Distribution

    \n This class is part of generative model and uses probility density map `m` to generate
    locations `loc`  `x`, `y`, `z` offsets and `ints` intensity of emitters. `m` should be
    `torch.tensor` scaled from 0.001 to 1, which is used by `_sample_bin` to generate `0` and
    `1` . `0` means that we dont have emitter at given pixel and 1 means emitters is presnet. This
    map is used to generate offset in `x`, `y`, `z` and intensities which tells how bright is emitter
    or in same casses how many emitters are bound to RNA molecules.


    \nParameters:
    \n`min_int`     : minimum intensity of emitters

    \nReturns:
    \n`locs`: locations of the emitters
    \n`x_os`: x offset of the emitters
    \n`y_os`: y offset of the emitters
    \n`z_os`: z offset of the emitters
    \n`ints`: z intensity of the emitters


    """

    def __init__(self, min_int: float):
        self.min_int = min_int

    def __call__(self, m):
        super().__call__(m)
        dev = self._get_device(m)
        zeros = torch.zeros_like(m)
        locs  = self._sample_bin(1, m).to(dev)
        x_os  = self._sample_uni(zeros-0.5, zeros+0.5).to(dev)
        y_os  = self._sample_uni(zeros-0.5, zeros+0.5).to(dev)
        z_os  = self._sample_uni(zeros-0.5, zeros+0.5).to(dev)
        ints  = self._sample_uni(zeros+self.min_int, torch.ones_like(zeros)).to(dev)
        x_os *= locs
        y_os *= locs
        z_os *= locs
        ints *= locs
        return locs, x_os, y_os, z_os, ints

    @staticmethod
    def _sample_uni(low, high):
        return getattr(torch.distributions, 'Uniform')(low=low, high=high).sample()

    @staticmethod
    def _sample_bin(total_count, probs, **kwargs):
        return getattr(torch.distributions, 'Binomial')(total_count=total_count, probs=probs, **kwargs).sample()

