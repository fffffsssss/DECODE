# AUTOGENERATED! DO NOT EDIT! File to edit: 01_simulation.ipynb (unless otherwise specified).

__all__ = ['tiff_imread', 'hasattrs', 'show_image', 'tst_check_tensor', 'ScaleTensor', 'Sample3D']

# Cell
from pathlib import Path
from tifffile import imread
import numpy as np
import matplotlib.pyplot as plt
import torch

# Cell
def tiff_imread(path):
    '''helper function to read tiff file with pathlib object or str'''
    if isinstance(path, str) : return imread(path)
    if isinstance(path, Path): return imread(str(path))


def hasattrs(o,attrs):
    "checks of o has several attrs"
    return all(hasattr(o,attr) for attr in attrs)


def show_image(im, ax=None, title=None, figsize=(4, 5), **kwargs,):
    'plots image from nump or tensor'
    if hasattrs(im, ('data','cpu','permute')):
        im = im.data.cpu()
        if im.shape[0]<5: im=im.permute(1,2,0)
    elif not isinstance(im,np.ndarray): im=array(im)
    if im.shape[-1]==1: im=im[...,0]
    if ax is None: _,ax = plt.subplots(figsize=figsize)
    ax.imshow(im, **kwargs)
    if title is not None: ax.set_title(title)
    ax.axis('off')
    return ax

# Cell
def tst_check_tensor(x):
    "cehcks if x is torch.Tensor"
    assert type(x) == torch.Tensor, f'Must be torch.tensor not {type(x)}'
    return

# Cell
class ScaleTensor:
    """Scales given `torch.Tensor` between `low` and `high`
       \n`low`     : lower bound
       \n`high`    : upper bound
       \n`data_min`: max value of data
       \n`data_max`: min value of main data

    """
    _order = 1
    def __init__(self, low, high, data_min, data_max):
        self.ratio = (high-low) /(data_max-data_min)
        self.data_min, self.low = data_min, low

    def __call__(self, x) -> torch.Tensor:
        tst_check_tensor(x)
        return self.ratio * x + self.low- self.data_min * self.ratio

# Cell
def _get_uniform(low, high):
    return getattr(torch.distributions, 'Uniform')(low=low, high=high).sample()

def _get_binomial(total_count, probs, **kwargs):
    return getattr(torch.distributions, 'Binomial')(total_count=total_count, probs=probs, **kwargs).sample()

# Cell
class Sample3D:
    """Samples from `3D` distributions and returns locations `locs` of emitters, `x`, `y`, `z` offsets and `ints` intensities`
       \n`min_ints`: approx minumal intensities of measured emitters

    """
    _order = 2
    def __init__(self, min_int: float):
        self.min_int = min_int

    def __call__(self, x):
        tst_check_tensor(x)
        dev = self._get_device(x)
        zeros = torch.zeros_like(x)
        locs  = _get_binomial(1, x).to(dev)
        x_os  = _get_uniform(zeros-0.5, zeros+0.5).to(dev)
        y_os  = _get_uniform(zeros-0.5, zeros+0.5).to(dev)
        z_os  = _get_uniform(zeros-0.5, zeros+0.5).to(dev)
        ints  = _get_uniform(zeros+self.min_int, torch.ones_like(zeros)).to(dev)
        x_os *= locs
        y_os *= locs
        z_os *= locs
        ints *= locs
        return locs, x_os, y_os, z_os, ints

    @staticmethod
    def _get_device(x):
        return getattr(x, 'device')